Coding Style
############

The coding style used in QuantumFS with golang is defined by these simple rules:

1. Use go fmt
2. Tabs are eight spaces
3. The maximum line length is 85 characters
4. When wrapping indent with one tab. If the following code would be at the same
   level insert a blank line.

These simple rules can be challenging to implement and appease go fmt at the same
time. Here are examples of mutually acceptable formatting in some of these
challenging cases. For the purposes of discussion all the examples below will assume
a maximum line length of 60.

Long Function Signature
=======================

If you have a long function signature, you must wrap after a comma. Because indenting
one level will put the continuation of the signature at the same level as the code,
insert a blank line after the wrapped function signature. ie.

  0         1         2         3         4         5         *         7         8
  01234567890123456789012345678901234567890123456789012345678901234567890123456789012
> func (fi *File) OpenDir(c *ctx, context fuse.Context, flags uint32) fuse.Status {
>       var foo int

would be wrapped

  0         1         2         3         4         5         *         7         8
  01234567890123456789012345678901234567890123456789012345678901234567890123456789012
> func (fi *File) OpenDir(c *ctx, context fuse.Context,
>         flags uint32) fuse.Status {
> 
>         var foo int

Note the blank line following the function signature.

Unfortunately go fmt demands wrapping a functions signature after a comma. Wrapping
between the argument list and the return list is not allowed. Thus you must wrap the
last argument as well:

  0         1         2         3         4         5         *         7         8
  01234567890123456789012345678901234567890123456789012345678901234567890123456789012
> func (fi *File) OpenDir(c *ctx, context fuse.Context) fuse.Status {
>       var foo int

Needs to be wrapped like so:

  0         1         2         3         4         5         *         7         8
  01234567890123456789012345678901234567890123456789012345678901234567890123456789012
> func (fi *File) OpenDir(c *ctx,
>       context fuse.Context) fuse.Status {
> 
>       var foo int


If-Statements
=============

Wrapping long if-statements is also somewhat challenging due to the automatic
semicolon insertion rule, especially if the idiomatic "if err := somecall(); err !=
nil {" style is used. Although ugly options appear to be restricted to using the less
idomatic form:

> err := somecall()
> if err != nil {

or wrapping the line in the argument list for somecall(). For the same reasons as
with long functions signatures a blank line is necessary. ie:

  0         1         2         3         4         5         *         7         8
  01234567890123456789012345678901234567890123456789012345678901234567890123456789012
>        if err := c.workspaceDB.BranchWorkspace(src, dst); err != nil {
>                api = 6

must be wrapped like:

  0         1         2         3         4         5         *         7         8
  01234567890123456789012345678901234567890123456789012345678901234567890123456789012
>        if err := c.workspaceDB.BranchWorkspace(src,
>                dst); err != nil {
> 
>                api = 6

Naming Conventions
##################

Test filenames
==============

Test filenames start with a capital letter and end with "_test".

Function Names
==============

Function names follow the golang style. An important extension of this is that
functions which expect a particular lock to already be held by the caller will have
an underscore ("_") appended to the function name. There must also be a comment for
the function describing the minimum lock(s) which must be held.

Locking and Critical Sections
#############################

Consider the following code:

> func (obj *Obj) a() {
>       obj.doSomethingExpensive1()
>
>       obj.lock.Lock()
>       obj.doSomethingImportant()
>       obj.lock.Unlock()
>
>       obj.doSomethingExpensive2()
> }

On the face of it this code seems simple, safe and efficient; both the expensive
operations are done without the lock held and the lock is released after the minimal
critical code is executed. Unfortunately this code is not panic safe and should
doSomethingImportant() panic, perhaps because of a coding error or other unavoidable
error, then obj.lock will never be unlocked. The next time this code comes around it
will deadlock.

In order to make this code safe we need to defer the Unlock() to ensure that, should
a panic happen while we are holding the lock that it is released. Employing this
advice literally we would end up with code as such:

> func (obj *Obj) a() {
>       obj.doSomethingExpensive1()
>
>       obj.lock.Lock()
>       defer obj.lock.Unlock()
>       obj.doSomethingImportant()
>
>       obj.doSomethingExpensive2()
> }

Unfortunately while this code is now safe from panics and will not leak the lock, it
also holds the lock during an expensive operation, doSomethingExpensive2(). This is
because, in the case without panics, deferred functions are only called at function
exit. Therefore all critical sections need to be their own separate function to
ensure the locks are always released and cover a minimal amount of execution. The
final and correct style for a critical section would thus be:

> func (obj *Obj) a() {
>       obj.doSomethingExpensive1()
>
>       func() {
>               obj.lock.Lock()
>               defer obj.lock.Unlock()
>               obj.doSomethingImportant()
>       }()
>
>       obj.doSomethingExpensive2()
> }

For convenience InodeCommon has a helper method which allows locking of the form:

> func (file *File a() {
>       file.doSomethingExpensive1()
>
>       func() {
>               defer file.Lock().Unlock()
>               file.doSomethingImportant()
>       }()
>
>       file.doSomethingExpensive2()
> }
